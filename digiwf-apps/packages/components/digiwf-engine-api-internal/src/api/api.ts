/* tslint:disable */
/* eslint-disable */
/**
 * DigiWF API
 * DigiWF - Plattform zur Digitalisierung von Workflows bei der LHM
 *
 * The version of the OpenAPI document: 0.34.0-SNAPSHOT
 * Contact: itm.digiwf@muenchen.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AlwMetaDataTO
 */
export interface AlwMetaDataTO {
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'contentSize'?: string;
}
/**
 * 
 * @export
 * @interface ButtonTO
 */
export interface ButtonTO {
    /**
     * 
     * @type {boolean}
     * @memberof ButtonTO
     */
    'showButton'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ButtonTO
     */
    'buttonText'?: string;
}
/**
 * 
 * @export
 * @interface ButtonsTO
 */
export interface ButtonsTO {
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    'complete'?: ButtonTO;
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    'cancel'?: ButtonTO;
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    'statusPdf'?: ButtonTO;
}
/**
 * 
 * @export
 * @interface CompleteTO
 */
export interface CompleteTO {
    /**
     * 
     * @type {string}
     * @memberof CompleteTO
     */
    'taskId': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CompleteTO
     */
    'variables': { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ConfigEntryTO
 */
export interface ConfigEntryTO {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface DeploymentDto
 */
export interface DeploymentDto {
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'deploymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'versionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'artifactType'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentStatusDto
 */
export interface DeploymentStatusDto {
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentStatusDto
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStatusDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FollowUpTO
 */
export interface FollowUpTO {
    /**
     * 
     * @type {string}
     * @memberof FollowUpTO
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpTO
     */
    'followUpDate'?: string;
}
/**
 * 
 * @export
 * @interface FormFieldTO
 */
export interface FormFieldTO {
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'defaultValueField'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'prependIcon'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'tooltip'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'ext'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    'multiple'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'ldapOus'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'imageHeight'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'imageWidth'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    'readonly'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FormFieldTO
     */
    'rows'?: number;
    /**
     * 
     * @type {number}
     * @memberof FormFieldTO
     */
    'col'?: number;
    /**
     * 
     * @type {Array<ItemTO>}
     * @memberof FormFieldTO
     */
    'items'?: Array<ItemTO>;
    /**
     * 
     * @type {Array<RuleTO>}
     * @memberof FormFieldTO
     */
    'rules'?: Array<RuleTO>;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'itemText'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'itemValue'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    'returnObject'?: boolean;
}
/**
 * 
 * @export
 * @interface FormTO
 */
export interface FormTO {
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    'authorizedGroups'?: string;
    /**
     * 
     * @type {ButtonsTO}
     * @memberof FormTO
     */
    'buttons'?: ButtonsTO;
    /**
     * 
     * @type {Array<GroupTO>}
     * @memberof FormTO
     */
    'groups'?: Array<GroupTO>;
}
/**
 * 
 * @export
 * @interface GetAlwMetadataTO
 */
export interface GetAlwMetadataTO {
    /**
     * 
     * @type {string}
     * @memberof GetAlwMetadataTO
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GetMetadataTO
 */
export interface GetMetadataTO {
    /**
     * 
     * @type {string}
     * @memberof GetMetadataTO
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GroupTO
 */
export interface GroupTO {
    /**
     * 
     * @type {string}
     * @memberof GroupTO
     */
    'label'?: string;
    /**
     * 
     * @type {Array<FormFieldTO>}
     * @memberof GroupTO
     */
    'schema'?: Array<FormFieldTO>;
}
/**
 * 
 * @export
 * @interface HistoryTask
 */
export interface HistoryTask {
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @interface HumanTaskDetailTO
 */
export interface HumanTaskDetailTO {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'processName': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'processInstanceId': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'assignee'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'assigneeFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'followUpDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'creationTime': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HumanTaskDetailTO
     */
    'variables'?: { [key: string]: object; };
    /**
     * 
     * @type {FormTO}
     * @memberof HumanTaskDetailTO
     */
    'form'?: FormTO;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HumanTaskDetailTO
     */
    'jsonSchema'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof HumanTaskDetailTO
     */
    'statusDocument'?: boolean;
}
/**
 * 
 * @export
 * @interface HumanTaskTO
 */
export interface HumanTaskTO {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'processName'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'assignee'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'assigneeFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'followUpDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'creationTime'?: string;
}
/**
 * 
 * @export
 * @interface InfoTO
 */
export interface InfoTO {
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    'maintenanceInfo1'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    'maintenanceInfo2'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    'environment'?: string;
}
/**
 * 
 * @export
 * @interface ItemTO
 */
export interface ItemTO {
    /**
     * 
     * @type {string}
     * @memberof ItemTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface JsonSchemaTO
 */
export interface JsonSchemaTO {
    /**
     * 
     * @type {string}
     * @memberof JsonSchemaTO
     */
    'key': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof JsonSchemaTO
     */
    'schema': { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface MetadataTO
 */
export interface MetadataTO {
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ProcessConfigTO
 */
export interface ProcessConfigTO {
    /**
     * 
     * @type {string}
     * @memberof ProcessConfigTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfigTO
     */
    'statusDokument'?: string;
    /**
     * 
     * @type {Array<StatusConfigTO>}
     * @memberof ProcessConfigTO
     */
    'statusConfig'?: Array<StatusConfigTO>;
    /**
     * 
     * @type {Array<ConfigEntryTO>}
     * @memberof ProcessConfigTO
     */
    'configs'?: Array<ConfigEntryTO>;
}
/**
 * 
 * @export
 * @interface RuleTO
 */
export interface RuleTO {
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface SaveTO
 */
export interface SaveTO {
    /**
     * 
     * @type {string}
     * @memberof SaveTO
     */
    'taskId': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SaveTO
     */
    'variables'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface SearchUserTO
 */
export interface SearchUserTO {
    /**
     * 
     * @type {string}
     * @memberof SearchUserTO
     */
    'searchString'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchUserTO
     */
    'ous'?: string;
}
/**
 * 
 * @export
 * @interface SendMessageTO
 */
export interface SendMessageTO {
    /**
     * 
     * @type {string}
     * @memberof SendMessageTO
     */
    'instanceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SendMessageTO
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ServiceDefinitionDetailTO
 */
export interface ServiceDefinitionDetailTO {
    /**
     * 
     * @type {FormTO}
     * @memberof ServiceDefinitionDetailTO
     */
    'startForm'?: FormTO;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceDefinitionDetailTO
     */
    'jsonSchema'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'versionTag'?: string;
}
/**
 * 
 * @export
 * @interface ServiceDefinitionTO
 */
export interface ServiceDefinitionTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'versionTag'?: string;
}
/**
 * 
 * @export
 * @interface ServiceInstanceDetailTO
 */
export interface ServiceInstanceDetailTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'definitionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'statusKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'description'?: string;
    /**
     * 
     * @type {ProcessConfigTO}
     * @memberof ServiceInstanceDetailTO
     */
    'processConfig'?: ProcessConfigTO;
    /**
     * 
     * @type {Array<HistoryTask>}
     * @memberof ServiceInstanceDetailTO
     */
    'historyTasks'?: Array<HistoryTask>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceInstanceDetailTO
     */
    'data'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceInstanceDetailTO
     */
    'jsonSchema'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ServiceInstanceTO
 */
export interface ServiceInstanceTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'definitionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface StartInstanceTO
 */
export interface StartInstanceTO {
    /**
     * 
     * @type {string}
     * @memberof StartInstanceTO
     */
    'key'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof StartInstanceTO
     */
    'variables'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface StatusConfigTO
 */
export interface StatusConfigTO {
    /**
     * 
     * @type {string}
     * @memberof StatusConfigTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof StatusConfigTO
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof StatusConfigTO
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface StatusDokumentTO
 */
export interface StatusDokumentTO {
    /**
     * 
     * @type {string}
     * @memberof StatusDokumentTO
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatusDokumentTO
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'lhmObjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'ou'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'department'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'email'?: string;
}

/**
 * AlwDmsRestControllerApi - axios parameter creator
 * @export
 */
export const AlwDmsRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (getAlwMetadataTO: GetAlwMetadataTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAlwMetadataTO' is not null or undefined
            assertParamExists('getMetadata', 'getAlwMetadataTO', getAlwMetadataTO)
            const localVarPath = `/rest/alwdms/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAlwMetadataTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlwDmsRestControllerApi - functional programming interface
 * @export
 */
export const AlwDmsRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlwDmsRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlwMetaDataTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(getAlwMetadataTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlwDmsRestControllerApi - factory interface
 * @export
 */
export const AlwDmsRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlwDmsRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: any): AxiosPromise<AlwMetaDataTO> {
            return localVarFp.getMetadata(getAlwMetadataTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlwDmsRestControllerApi - object-oriented interface
 * @export
 * @class AlwDmsRestControllerApi
 * @extends {BaseAPI}
 */
export class AlwDmsRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {GetAlwMetadataTO} getAlwMetadataTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlwDmsRestControllerApi
     */
    public getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: AxiosRequestConfig) {
        return AlwDmsRestControllerApiFp(this.configuration).getMetadata(getAlwMetadataTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentControllerApi - axios parameter creator
 * @export
 */
export const DeploymentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeploymentDto} deploymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployArtifacts: async (deploymentDto: DeploymentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentDto' is not null or undefined
            assertParamExists('deployArtifacts', 'deploymentDto', deploymentDto)
            const localVarPath = `/rest/deployment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentControllerApi - functional programming interface
 * @export
 */
export const DeploymentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeploymentDto} deploymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployArtifacts(deploymentDto: DeploymentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployArtifacts(deploymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentControllerApi - factory interface
 * @export
 */
export const DeploymentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {DeploymentDto} deploymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployArtifacts(deploymentDto: DeploymentDto, options?: any): AxiosPromise<DeploymentStatusDto> {
            return localVarFp.deployArtifacts(deploymentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentControllerApi - object-oriented interface
 * @export
 * @class DeploymentControllerApi
 * @extends {BaseAPI}
 */
export class DeploymentControllerApi extends BaseAPI {
    /**
     * 
     * @param {DeploymentDto} deploymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentControllerApi
     */
    public deployArtifacts(deploymentDto: DeploymentDto, options?: AxiosRequestConfig) {
        return DeploymentControllerApiFp(this.configuration).deployArtifacts(deploymentDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DmsRestControllerApi - axios parameter creator
 * @export
 */
export const DmsRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaData: async (getMetadataTO: GetMetadataTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getMetadataTO' is not null or undefined
            assertParamExists('getMetaData', 'getMetadataTO', getMetadataTO)
            const localVarPath = `/rest/dms/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetadataTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DmsRestControllerApi - functional programming interface
 * @export
 */
export const DmsRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DmsRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaData(getMetadataTO: GetMetadataTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaData(getMetadataTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DmsRestControllerApi - factory interface
 * @export
 */
export const DmsRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DmsRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaData(getMetadataTO: GetMetadataTO, options?: any): AxiosPromise<MetadataTO> {
            return localVarFp.getMetaData(getMetadataTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DmsRestControllerApi - object-oriented interface
 * @export
 * @class DmsRestControllerApi
 * @extends {BaseAPI}
 */
export class DmsRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {GetMetadataTO} getMetadataTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DmsRestControllerApi
     */
    public getMetaData(getMetadataTO: GetMetadataTO, options?: AxiosRequestConfig) {
        return DmsRestControllerApiFp(this.configuration).getMetaData(getMetadataTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentRestControllerApi - axios parameter creator
 * @export
 */
export const DocumentRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDokumentForTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStatusDokumentForTask', 'id', id)
            const localVarPath = `/rest/document/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentRestControllerApi - functional programming interface
 * @export
 */
export const DocumentRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDokumentForTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDokumentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDokumentForTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentRestControllerApi - factory interface
 * @export
 */
export const DocumentRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDokumentForTask(id: string, options?: any): AxiosPromise<StatusDokumentTO> {
            return localVarFp.getStatusDokumentForTask(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentRestControllerApi - object-oriented interface
 * @export
 * @class DocumentRestControllerApi
 * @extends {BaseAPI}
 */
export class DocumentRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentRestControllerApi
     */
    public getStatusDokumentForTask(id: string, options?: AxiosRequestConfig) {
        return DocumentRestControllerApiFp(this.configuration).getStatusDokumentForTask(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FormRestControllerApi - axios parameter creator
 * @export
 */
export const FormRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForm: async (formTO: FormTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formTO' is not null or undefined
            assertParamExists('createForm', 'formTO', formTO)
            const localVarPath = `/rest/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getForm', 'key', key)
            const localVarPath = `/rest/form/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm: async (key: string, formTO: FormTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateForm', 'key', key)
            // verify required parameter 'formTO' is not null or undefined
            assertParamExists('updateForm', 'formTO', formTO)
            const localVarPath = `/rest/form/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormRestControllerApi - functional programming interface
 * @export
 */
export const FormRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForm(formTO: FormTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForm(formTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForm(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FormTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForm(key: string, formTO: FormTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateForm(key, formTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FormRestControllerApi - factory interface
 * @export
 */
export const FormRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForm(formTO: FormTO, options?: any): AxiosPromise<FormTO> {
            return localVarFp.createForm(formTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(key: string, options?: any): AxiosPromise<FormTO> {
            return localVarFp.getForm(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForms(options?: any): AxiosPromise<Array<FormTO>> {
            return localVarFp.getForms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm(key: string, formTO: FormTO, options?: any): AxiosPromise<FormTO> {
            return localVarFp.updateForm(key, formTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FormRestControllerApi - object-oriented interface
 * @export
 * @class FormRestControllerApi
 * @extends {BaseAPI}
 */
export class FormRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {FormTO} formTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public createForm(formTO: FormTO, options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).createForm(formTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public getForm(key: string, options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).getForm(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public getForms(options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).getForms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {FormTO} formTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public updateForm(key: string, formTO: FormTO, options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).updateForm(key, formTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HumanTaskFileRestControllerApi - axios parameter creator
 * @export
 */
export const HumanTaskFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames: async (taskId: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getFileNames', 'taskId', taskId)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion: async (taskId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'taskId', taskId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}/{filename}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload: async (taskId: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'taskId', taskId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}/{fileName}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload: async (taskId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'taskId', taskId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}/{filename}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HumanTaskFileRestControllerApi - functional programming interface
 * @export
 */
export const HumanTaskFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HumanTaskFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames(taskId: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames(taskId, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion(taskId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion(taskId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload(taskId: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload(taskId, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload(taskId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload(taskId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HumanTaskFileRestControllerApi - factory interface
 * @export
 */
export const HumanTaskFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HumanTaskFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames(taskId: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames(taskId, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion(taskId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion(taskId, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload(taskId: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload(taskId, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload(taskId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload(taskId, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HumanTaskFileRestControllerApi - object-oriented interface
 * @export
 * @class HumanTaskFileRestControllerApi
 * @extends {BaseAPI}
 */
export class HumanTaskFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} taskId 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getFileNames(taskId: string, filePath: string, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getFileNames(taskId, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {string} filename 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion(taskId: string, filename: string, filePath: string, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion(taskId, filename, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {string} fileName 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileDownload(taskId: string, fileName: string, filePath: string, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload(taskId, fileName, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {string} filename 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileUpload(taskId: string, filename: string, filePath: string, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload(taskId, filename, filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HumanTaskRestControllerApi - axios parameter creator
 * @export
 */
export const HumanTaskRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignTask', 'id', id)
            const localVarPath = `/rest/task/assign/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTask', 'id', id)
            const localVarPath = `/rest/task/cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (completeTO: CompleteTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeTO' is not null or undefined
            assertParamExists('completeTask', 'completeTO', completeTO)
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUpTask: async (followUpTO: FollowUpTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followUpTO' is not null or undefined
            assertParamExists('followUpTask', 'followUpTO', followUpTO)
            const localVarPath = `/rest/task/followup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followUpTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task/group/assigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenGroupTasks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task/group/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskDetail', 'id', id)
            const localVarPath = `/rest/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask: async (saveTO: SaveTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveTO' is not null or undefined
            assertParamExists('saveTask', 'saveTO', saveTO)
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HumanTaskRestControllerApi - functional programming interface
 * @export
 */
export const HumanTaskRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HumanTaskRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(completeTO: CompleteTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(completeTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUpTask(followUpTO: FollowUpTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUpTask(followUpTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedGroupTasks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanTaskTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedGroupTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenGroupTasks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanTaskTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenGroupTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskDetail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HumanTaskDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanTaskTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTask(saveTO: SaveTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HumanTaskDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTask(saveTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HumanTaskRestControllerApi - factory interface
 * @export
 */
export const HumanTaskRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HumanTaskRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.assignTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(completeTO: CompleteTO, options?: any): AxiosPromise<void> {
            return localVarFp.completeTask(completeTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUpTask(followUpTO: FollowUpTO, options?: any): AxiosPromise<void> {
            return localVarFp.followUpTask(followUpTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks(options?: any): AxiosPromise<Array<HumanTaskTO>> {
            return localVarFp.getAssignedGroupTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenGroupTasks(options?: any): AxiosPromise<Array<HumanTaskTO>> {
            return localVarFp.getOpenGroupTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail(id: string, options?: any): AxiosPromise<HumanTaskDetailTO> {
            return localVarFp.getTaskDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(options?: any): AxiosPromise<Array<HumanTaskTO>> {
            return localVarFp.getTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask(saveTO: SaveTO, options?: any): AxiosPromise<HumanTaskDetailTO> {
            return localVarFp.saveTask(saveTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HumanTaskRestControllerApi - object-oriented interface
 * @export
 * @class HumanTaskRestControllerApi
 * @extends {BaseAPI}
 */
export class HumanTaskRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public assignTask(id: string, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).assignTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public cancelTask(id: string, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).cancelTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompleteTO} completeTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public completeTask(completeTO: CompleteTO, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).completeTask(completeTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FollowUpTO} followUpTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public followUpTask(followUpTO: FollowUpTO, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).followUpTask(followUpTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getAssignedGroupTasks(options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getAssignedGroupTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getOpenGroupTasks(options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getOpenGroupTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getTaskDetail(id: string, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getTaskDetail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getTasks(options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveTO} saveTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public saveTask(saveTO: SaveTO, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).saveTask(saveTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoRestControllerApi - axios parameter creator
 * @export
 */
export const InfoRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoRestControllerApi - functional programming interface
 * @export
 */
export const InfoRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoRestControllerApi - factory interface
 * @export
 */
export const InfoRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<InfoTO> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoRestControllerApi - object-oriented interface
 * @export
 * @class InfoRestControllerApi
 * @extends {BaseAPI}
 */
export class InfoRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoRestControllerApi
     */
    public getInfo(options?: AxiosRequestConfig) {
        return InfoRestControllerApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageControllerApi - axios parameter creator
 * @export
 */
export const MessageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (sendMessageTO: SendMessageTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMessageTO' is not null or undefined
            assertParamExists('sendMessage', 'sendMessageTO', sendMessageTO)
            const localVarPath = `/rest/input/message/send/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageControllerApi - functional programming interface
 * @export
 */
export const MessageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(sendMessageTO: SendMessageTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(sendMessageTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageControllerApi - factory interface
 * @export
 */
export const MessageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(sendMessageTO: SendMessageTO, options?: any): AxiosPromise<void> {
            return localVarFp.sendMessage(sendMessageTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageControllerApi - object-oriented interface
 * @export
 * @class MessageControllerApi
 * @extends {BaseAPI}
 */
export class MessageControllerApi extends BaseAPI {
    /**
     * 
     * @param {SendMessageTO} sendMessageTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageControllerApi
     */
    public sendMessage(sendMessageTO: SendMessageTO, options?: AxiosRequestConfig) {
        return MessageControllerApiFp(this.configuration).sendMessage(sendMessageTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessConfigurationControllerApi - axios parameter creator
 * @export
 */
export const ProcessConfigurationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfig: async (processConfigTO: ProcessConfigTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processConfigTO' is not null or undefined
            assertParamExists('createConfig', 'processConfigTO', processConfigTO)
            const localVarPath = `/rest/processconfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processConfigTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getConfig', 'key', key)
            const localVarPath = `/rest/processconfig/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessConfigurationControllerApi - functional programming interface
 * @export
 */
export const ProcessConfigurationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessConfigurationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConfig(processConfigTO: ProcessConfigTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessConfigTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConfig(processConfigTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessConfigTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessConfigurationControllerApi - factory interface
 * @export
 */
export const ProcessConfigurationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessConfigurationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfig(processConfigTO: ProcessConfigTO, options?: any): AxiosPromise<ProcessConfigTO> {
            return localVarFp.createConfig(processConfigTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options?: any): AxiosPromise<ProcessConfigTO> {
            return localVarFp.getConfig(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessConfigurationControllerApi - object-oriented interface
 * @export
 * @class ProcessConfigurationControllerApi
 * @extends {BaseAPI}
 */
export class ProcessConfigurationControllerApi extends BaseAPI {
    /**
     * 
     * @param {ProcessConfigTO} processConfigTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessConfigurationControllerApi
     */
    public createConfig(processConfigTO: ProcessConfigTO, options?: AxiosRequestConfig) {
        return ProcessConfigurationControllerApiFp(this.configuration).createConfig(processConfigTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessConfigurationControllerApi
     */
    public getConfig(key: string, options?: AxiosRequestConfig) {
        return ProcessConfigurationControllerApiFp(this.configuration).getConfig(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaRestControllerApi - axios parameter creator
 * @export
 */
export const SchemaRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJsonSchema: async (jsonSchemaTO: JsonSchemaTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonSchemaTO' is not null or undefined
            assertParamExists('createJsonSchema', 'jsonSchemaTO', jsonSchemaTO)
            const localVarPath = `/rest/jsonschema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonSchemaTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonSchema: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getJsonSchema', 'key', key)
            const localVarPath = `/rest/jsonschema/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaRestControllerApi - functional programming interface
 * @export
 */
export const SchemaRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchemaTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJsonSchema(jsonSchemaTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonSchema(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchemaTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonSchema(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaRestControllerApi - factory interface
 * @export
 */
export const SchemaRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaRestControllerApiFp(configuration)
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: any): AxiosPromise<JsonSchemaTO> {
            return localVarFp.createJsonSchema(jsonSchemaTO, options).then((request) => request(axios, basePath));
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonSchema(key: string, options?: any): AxiosPromise<JsonSchemaTO> {
            return localVarFp.getJsonSchema(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaRestControllerApi - object-oriented interface
 * @export
 * @class SchemaRestControllerApi
 * @extends {BaseAPI}
 */
export class SchemaRestControllerApi extends BaseAPI {
    /**
     * create a new json schema
     * @param {JsonSchemaTO} jsonSchemaTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaRestControllerApi
     */
    public createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: AxiosRequestConfig) {
        return SchemaRestControllerApiFp(this.configuration).createJsonSchema(jsonSchemaTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get json schema by key
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaRestControllerApi
     */
    public getJsonSchema(key: string, options?: AxiosRequestConfig) {
        return SchemaRestControllerApiFp(this.configuration).getJsonSchema(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceDefinitionControllerApi - axios parameter creator
 * @export
 */
export const ServiceDefinitionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinition: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getServiceDefinition', 'key', key)
            const localVarPath = `/rest/service/definition/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/service/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance: async (startInstanceTO: StartInstanceTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startInstanceTO' is not null or undefined
            assertParamExists('startInstance', 'startInstanceTO', startInstanceTO)
            const localVarPath = `/rest/service/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startInstanceTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDefinitionControllerApi - functional programming interface
 * @export
 */
export const ServiceDefinitionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDefinitionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDefinition(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDefinitionDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDefinition(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDefinitions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDefinitionTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDefinitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startInstance(startInstanceTO: StartInstanceTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startInstance(startInstanceTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceDefinitionControllerApi - factory interface
 * @export
 */
export const ServiceDefinitionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDefinitionControllerApiFp(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinition(key: string, options?: any): AxiosPromise<ServiceDefinitionDetailTO> {
            return localVarFp.getServiceDefinition(key, options).then((request) => request(axios, basePath));
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions(options?: any): AxiosPromise<Array<ServiceDefinitionTO>> {
            return localVarFp.getServiceDefinitions(options).then((request) => request(axios, basePath));
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance(startInstanceTO: StartInstanceTO, options?: any): AxiosPromise<void> {
            return localVarFp.startInstance(startInstanceTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceDefinitionControllerApi - object-oriented interface
 * @export
 * @class ServiceDefinitionControllerApi
 * @extends {BaseAPI}
 */
export class ServiceDefinitionControllerApi extends BaseAPI {
    /**
     * Get a specific service definition
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public getServiceDefinition(key: string, options?: AxiosRequestConfig) {
        return ServiceDefinitionControllerApiFp(this.configuration).getServiceDefinition(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * load all available service definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public getServiceDefinitions(options?: AxiosRequestConfig) {
        return ServiceDefinitionControllerApiFp(this.configuration).getServiceDefinitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a specific service
     * @param {StartInstanceTO} startInstanceTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public startInstance(startInstanceTO: StartInstanceTO, options?: AxiosRequestConfig) {
        return ServiceDefinitionControllerApiFp(this.configuration).startInstance(startInstanceTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceInstanceControllerApi - axios parameter creator
 * @export
 */
export const ServiceInstanceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/service/instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessInstanceDetail', 'id', id)
            const localVarPath = `/rest/service/instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceInstanceControllerApi - functional programming interface
 * @export
 */
export const ServiceInstanceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceInstanceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedInstances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceInstanceTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedInstances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceDetail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstanceDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceInstanceControllerApi - factory interface
 * @export
 */
export const ServiceInstanceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceInstanceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances(options?: any): AxiosPromise<Array<ServiceInstanceTO>> {
            return localVarFp.getAssignedInstances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail(id: string, options?: any): AxiosPromise<ServiceInstanceDetailTO> {
            return localVarFp.getProcessInstanceDetail(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceInstanceControllerApi - object-oriented interface
 * @export
 * @class ServiceInstanceControllerApi
 * @extends {BaseAPI}
 */
export class ServiceInstanceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceControllerApi
     */
    public getAssignedInstances(options?: AxiosRequestConfig) {
        return ServiceInstanceControllerApiFp(this.configuration).getAssignedInstances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceControllerApi
     */
    public getProcessInstanceDetail(id: string, options?: AxiosRequestConfig) {
        return ServiceInstanceControllerApiFp(this.configuration).getProcessInstanceDetail(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceInstanceFileRestControllerApi - axios parameter creator
 * @export
 */
export const ServiceInstanceFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames2: async (instanceId: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getFileNames2', 'instanceId', instanceId)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion2: async (instanceId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion2', 'instanceId', instanceId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion2', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{filename}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload2: async (instanceId: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload2', 'instanceId', instanceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload2', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{fileName}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload2: async (instanceId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload2', 'instanceId', instanceId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload2', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{filename}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceInstanceFileRestControllerApi - functional programming interface
 * @export
 */
export const ServiceInstanceFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceInstanceFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames2(instanceId: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames2(instanceId, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion2(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion2(instanceId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload2(instanceId: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload2(instanceId, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload2(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload2(instanceId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceInstanceFileRestControllerApi - factory interface
 * @export
 */
export const ServiceInstanceFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceInstanceFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames2(instanceId: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames2(instanceId, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion2(instanceId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion2(instanceId, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload2(instanceId: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload2(instanceId, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload2(instanceId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload2(instanceId, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceInstanceFileRestControllerApi - object-oriented interface
 * @export
 * @class ServiceInstanceFileRestControllerApi
 * @extends {BaseAPI}
 */
export class ServiceInstanceFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} instanceId 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getFileNames2(instanceId: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getFileNames2(instanceId, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} instanceId 
     * @param {string} filename 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion2(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion2(instanceId, filename, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} instanceId 
     * @param {string} fileName 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileDownload2(instanceId: string, fileName: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload2(instanceId, fileName, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} instanceId 
     * @param {string} filename 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileUpload2(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload2(instanceId, filename, filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceStartFileRestControllerApi - axios parameter creator
 * @export
 */
export const ServiceStartFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames1: async (definitionKey: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getFileNames1', 'definitionKey', definitionKey)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion1: async (definitionKey: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'definitionKey', definitionKey)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{filename}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload1: async (definitionKey: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'definitionKey', definitionKey)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{fileName}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload1: async (definitionKey: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'definitionKey', definitionKey)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{filename}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceStartFileRestControllerApi - functional programming interface
 * @export
 */
export const ServiceStartFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceStartFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames1(definitionKey: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames1(definitionKey, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion1(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion1(definitionKey, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload1(definitionKey: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload1(definitionKey, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload1(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload1(definitionKey, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceStartFileRestControllerApi - factory interface
 * @export
 */
export const ServiceStartFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceStartFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames1(definitionKey: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames1(definitionKey, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion1(definitionKey: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion1(definitionKey, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload1(definitionKey: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload1(definitionKey, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload1(definitionKey: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload1(definitionKey, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceStartFileRestControllerApi - object-oriented interface
 * @export
 * @class ServiceStartFileRestControllerApi
 * @extends {BaseAPI}
 */
export class ServiceStartFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} definitionKey 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getFileNames1(definitionKey: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getFileNames1(definitionKey, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} definitionKey 
     * @param {string} filename 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion1(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion1(definitionKey, filename, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} definitionKey 
     * @param {string} fileName 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileDownload1(definitionKey: string, fileName: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload1(definitionKey, fileName, filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} definitionKey 
     * @param {string} filename 
     * @param {string} filePath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileUpload1(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload1(definitionKey, filename, filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserRestControllerApi - axios parameter creator
 * @export
 */
export const UserRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/rest/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/rest/user/uid/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (searchUserTO: SearchUserTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchUserTO' is not null or undefined
            assertParamExists('getUsers', 'searchUserTO', searchUserTO)
            const localVarPath = `/rest/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchUserTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRestControllerApi - functional programming interface
 * @export
 */
export const UserRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(searchUserTO: SearchUserTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(searchUserTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserRestControllerApi - factory interface
 * @export
 */
export const UserRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<UserTO> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: any): AxiosPromise<UserTO> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(searchUserTO: SearchUserTO, options?: any): AxiosPromise<Array<UserTO>> {
            return localVarFp.getUsers(searchUserTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo(options?: any): AxiosPromise<UserTO> {
            return localVarFp.userinfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserRestControllerApi - object-oriented interface
 * @export
 * @class UserRestControllerApi
 * @extends {BaseAPI}
 */
export class UserRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUserByUsername(username: string, options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).getUserByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchUserTO} searchUserTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUsers(searchUserTO: SearchUserTO, options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).getUsers(searchUserTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public userinfo(options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).userinfo(options).then((request) => request(this.axios, this.basePath));
    }
}


